进度：只写了dockerfile且dockerfile运行失败。dockerfile位置 E:\Security-Attack-Defense\blockchain\mush-audit-main\外部文件\Dockerfile

在开始具体的计划前，我们再次明确系统的核心架构，这能让你对最终作品有个清晰的画面：

*   **核心功能**：一个针对以太坊智能合约的**静态漏洞扫描系统**。
*   **技术栈**：
    *   **前端**：**Streamlit**。你用起来顺手，能快速构建交互式Web应用。
    *   **后端/扫描引擎**：**Python**。集成 **Slither** 和 **Mythril** 这两大主流分析工具，这也是你老师推荐的。
    *   **数据库**：**SQLite**。轻量级，适合原型开发。
*   **最终交付物**：一个可通过网页界面**上传Solidity代码（.sol文件）并获取详细漏洞报告**的完整应用。


### 🗓️ 详尽四阶段开发计划

下面的计划将4个月（约16周）分为四个清晰的阶段，并细化到每周的任务。

| 阶段            | 周期      | 核心目标                     | 关键产出                                                     |      |
| --------------- | --------- | ---------------------------- | ------------------------------------------------------------ | ---- |
| **1. 基础奠基** | 第1-4周   | 掌握核心概念，搭建开发环境   | 1. 能解释至少5种核心漏洞原理； 2. 在受限Docker/VM里成功运行Slither和Mythril。 | 12月 |
| **2. 核心攻坚** | 第5-8周   | 完成扫描引擎的核心逻辑       | 1. 可运行的Python脚本，能在受限Docker容器中调用分析工具并解析结果； 2. 设计好数据库表结构。<br/>3. 错误/超时处理机制。 | 1月  |
| **3. 系统集成** | 第9-12周  | 完成Streamlit UI并集成后端   | 1. 一个完整的Web应用，用户可通过界面完成一次完整扫描； 2. 漏洞结果在网页上清晰展示。 | 2月  |
| **4. 收尾答辩** | 第13-16周 | 系统优化、撰写文档、准备答辩 | 1. 可稳定运行的系统，包含容器化部署说明、毕设论文初稿、演示PPT和讲稿； <br/>2. 完成一次模拟答辩并修订论文。 | 3月  |

 

------



#### **阶段一：基础奠基 (第1-4周)**

这个阶段的目标是**搭建知识体系和开发环境**，是所有后续工作的基础。

| 周数      | 每周核心任务                                 | 每日To-do (约3小时)                                          |      |
| --------- | -------------------------------------------- | ------------------------------------------------------------ | ---- |
| **第1周** | **初识智能合约安全与实验环境**               | Day1 (3h): 阅读以太坊官方文档（执行层/EVM/gas/账户模型），做笔记。 <br/>:ballot_box_with_check:Day2 (3h): CryptoZombies 第1章实操（合约结构、函数、变量）。 <br/>:ballot_box_with_check:Day3 (3h): CryptoZombies 第2章实操（struct/mapping/数组/visibility）。 <br/>:ballot_box_with_check:Day4 (3h): 在 VM/WSL2 中搭建开发环境（Docker、Python3.8+、VSCode），为 VM 分配 6–8GB。 <br/>Day1 (3h): 深入阅读 SCSVS（挑选 Top 10 条目），为每条写出典型漏洞模式（code pattern）与检测方式。 <br/>每 （重点：重入、整数溢出、访问控制、未检查返回/外部调用、时间依赖）。天额外 1h：完成 1 个 Ethernaut 入门关卡并记录漏洞类型。原理和案例.并列出 5 个示例合约。<br/>Day6 (3h): 注册并浏览 Cyfrin Updraft，挑 2 个实操 lab 做（笔记 + 代码）。 <br/>:ballot_box_with_check:Day7 (3h): 在 Remix 部署并运行 2 个简单合约（验证环境可用），把源码提交到 Git。 |      |
| **第2周** | **工具安装 + 安全沙箱**                      | Day2 (3h): 将 SCSVS Top 10 映射到 EthTrust v3 相关条目，写出初版“SCSVS→EthTrust 映射表”。 <br/>​​每天额外 1h：完成 1 个 Ethernaut 关卡。<br />:ballot_box_with_check:Day1 (3h): 在 Docker 容器内安装 Slither，运行示例并理解 JSON 输出结构。 <br/>:star:（延伸）部署本地测试链 <br/>:star:Day2 (3h): 在容器中安装 Mythril，尝试 `myth analyze`，学习 timeout 配置与内存限制。 <br/>Day3 (3h): 在容器中写脚本封装 Slither（CLI→JSON），并记录常用参数。 <br/>Day4 (3h): 在容器中写 Mythril 的简单封装（含超时处理），做一次耗时记录实验。 <br/>Day5 (3h): 在 Remix 写含重入漏+洞的合约并用本地 Slither/Mythril 扫描，记录工具差异。 <br/>Day6 (3h): 收集工具耗时/内存数据，整理成 baseline 表格。 <br/>Day7 (3h): 把 Cyfrin 的另一个 lab（攻击/修复练习）完成并加入测试样本。<br />（新增）每天 1h：在 Ethernaut 完成至少 1 个入门关卡（如 Hello/Token/Shop 等），记录漏洞类型与触发步骤，并把关卡源码保存为测试样本。 |      |
| **第3周** | **漏洞复现与样本集合 + ScanEngine 初始设计** | Day1 (1h) 收集并编写 8–12 个含典型漏洞的合约（自己写 + SWC 示例 + Ethernaut 关卡源码），至少包含 1 个 Ethernaut 重入与 1 个整数/溢出练习。 <br/>（新增）(1h) 在本地用 Remix 或 Foundry 部署 2 个 Ethernaut 关卡并尝试复现/利用，记录 exploit 步骤与脚本。<br />Day2 (3h): 用 Slither 批量扫描这些合约，导出 JSON，汇总常见告警类型。 <br/>Day3 (3h): 设计 `Vulnerability` 数据模型（字段清单）并写草案。 <br/>Day4 (3h): 撰写 ScanEngine 高层设计（流程图：上传→预检→工具链→归一化→入库）。 <br/>Day5 (3h): 规划数据库 schema（scans、vulnerabilities、raw_outputs、agent_decisions）。 <br/>Day6 (3h): 在 README 中记录你使用的工具版本（solc/slither/mythril）以便答辩引用。 <br/>Day7 (3h): 把样本合约放到 `tests/fixtures`，并做第一次端到端手动扫描演示。 |      |
| **第4周** | **项目初始化与安全策略**                     | Day1 (3h): 撰写需求文档（功能清单、输入/输出、安全策略、容器化约束、超时策略）。 <br/>Day2 (3h): 初始化 Git 仓库、建立项目目录（src/tests/docs）、写 `requirements.txt` 与 `README` 初稿。 <br/>Day3 (3h): 写用于容器内安全运行工具的 demo 脚本（限制内存/禁网/超时），本地验证。 <br/>Day4 (3h): 实现上传文件的预检（大小/扩展名/简单静态扫描），防止明显恶意输入。 <br/>Day5 (3h): 写单元测试框架模板（pytest 或 unittest），为之后自动化测试打基础。 <br/>Day6 (3h): 把第一版系统架构图加入 docs 并把第1周至第4周成果归档。 <br/>Day7 (3h): 回顾周工作，整理问题清单并为下一阶段列出优先级。 |      |

#### **阶段二：核心攻坚 (第5-8周)**

这个阶段是系统的**大脑**，你要让扫描引擎在后台跑起来。

| 周数      | 每周核心任务                         | 每日To-do (约3小时)                                          |
| --------- | ------------------------------------ | ------------------------------------------------------------ |
| **第5周** | **Python 与 Slither 集成**           | Day1 (3h): 用 Python 的 `subprocess` 封装 Slither 调用（输入路径→JSON 输出）。 <br/>Day2 (3h): 编写 `Vulnerability` 类并实现从 Slither JSON 到类的映射。 <br/>Day3 (3h): 为 Slither wrapper 加入超时/错误处理与日志记录。 <br/>Day4 (3h): 编写小脚本批量处理多合约并把结果写回 SQLite（初版）。 <br/>Day5 (3h): 写单元测试覆盖 Slither wrapper 的成功/失败路径。 <br/>Day6 (3h): 测试并记录在不同合约规模下的 Slither 耗时。 <br/>Day7 (3h): 修复发现的问题并更新 docs。<br />（新增）每天 0.5–1h：用 Slither 批量扫描收集的 Ethernaut 关卡源码，记录工具告警并把告警与 SWC ID 做映射。 |
| **第6周** | **Mythril 可选调用 & 解析/融合逻辑** | Day1 (3h): 实现 Mythril 的 Docker wrapper（含超时与内存限制）。 <br/>Day2 (3h): 设计融合策略：当 Slither 输出触发哪些关键字时启动 Mythril（rule 列表）。 <br/>Day3 (3h): 实现并测试 Slither + Mythril 的输出合并（去重 by file+line+swc）。 <br/>Day4 (3h): 为 Myrthril wrapper 写异常回退（超时时记录警告并继续）。 <br/>Day5 (3h): 在样本集中运行混合分析，记录误报/漏报差异。（新增）合并规则时优先保障对 Ethernaut 常见漏洞的高召回（reentrancy、unchecked-call、integer overflow），并把 Ethernaut 的 exploit traces 存为证据样本。<br />Day6 (3h): 优化配置阈值（例如合约行数 > X 才触发 Mythril）。 <br/>Day7 (3h): 将规则写入 docs，准备下一步的自动决策层（Agent）。 |
| **第7周** | **数据库与持久化**                   | Day1 (3h): 设计并创建 SQLite 表（scans、vulnerabilities、raw_paths、metrics）。 <br/>Day2 (3h): 实现 `save_scan()` 与 `save_vulnerabilities()` API。 <br/>Day3 (3h): 实现 `list_scans()`、`get_scan(id)` 查询函数并写接口测试。 <br/>Day4 (3h): 将 raw JSON 输出保存为文件并把路径写入 DB（避免把大 JSON 写入表）。 <br/>Day5 (3h): 编写 DB 迁移/备份说明并测试恢复流程。 <br/>Day6 (3h): 做一次完整的端到端数据流测试（上传→扫描→入库→查询）。 <br/>Day7 (3h): 修复遇到的数据一致性问题并记录性能指标。 |
| **第8周** | **ScanEngine 封装**                  | Day1 (3h): 设计 `ScanEngine.scan(path)` API 规范与返回格式草案。 <br/>Day2 (3h): 实现 `ScanEngine.scan()`（写临时文件→启动容器→捕获输出→解析→入库→返回）。 <br/>Day3 (3h): 给 `ScanEngine` 加入超时/重试/断点恢复逻辑。 <br/>Day4 (3h): 为 `ScanEngine` 写集成测试（模拟容器超时、工具崩溃）。 <br/>Day5 (3h): 记录并优化 `ScanEngine` 的日志与监控点（时间、资源、错误码）。 <br/>Day6 (3h): 准备阶段三对接所需的 REST 或函数接口（供前端调用）。 <br/>Day7 (3h): 代码整理、注释与提交，准备进入 UI 集成。 |

#### **阶段三：系统集成 (第9-12周)**

这个阶段为系统**打造门面**，让用户（和答辩老师）能通过网页轻松使用。Agent（rule-based）作为可选功能在本阶段加入（保守路线）。

| 周数       | 每周核心任务                                | 每日To-do (约3小时)                                          |
| ---------- | ------------------------------------------- | ------------------------------------------------------------ |
| **第9周**  | **Streamlit 与 UX（MVP 前端）**             | Day1 (3h): 学习 Streamlit 基本组件并看示例项目。 <br/>Day2 (3h): 搭建 `app.py`：文件上传 + 显示已上传文件列表。 <br/>Day3 (3h): 实现“开始扫描”按钮同步调用 `ScanEngine.scan()`（阻塞模式做 MVP）。 <br/>Day4 (3h): 用 `st.spinner()` 显示扫描进度并把 stdout/stderr 部分流回前端。 <br/>Day5 (3h): 显示扫描摘要（scan_id、耗时、漏洞数量）。 <br/>Day6 (3h): 在前端实现基本错误提示（非 .sol 文件、超时提示）。 <br/>Day7 (3h): UI 小的美化与可用性测试。<br />（新增）构建演示页面：预置 2 个 Ethernaut 关卡作为 demo（显示源码 + 扫描结果 + exploit replay/演示步骤），用于答辩现场演示。 |
| **第10周** | **前后端联动 + Agent 架构设计（不写 LLM）** | Day1 (3h): 把 `ScanEngine` 改为异步任务（简单轮询或短轮询实现）。 <br/>Day2 (3h): 设计 Agent 的高层接口（输入：meta、历史；输出：tool plan），写接口文档。 <br/>Day3 (3h): 列出 rule-based Planner 的初始规则（至少 8 条），把规则写成可执行配置（JSON/YAML）。 <br/>Day4 (3h): 在前端增加“智能扫描（Rule-based）”开关与日志面板。 <br/>Day5 (3h): 实现 Planner 的简单模拟器（读取合约 meta，返回工具清单）。 <br/>Day6 (3h): 在后端加入 Planner 调用链（在用户选中“智能扫描”时先运行 Planner 再调度工具）。 <br/>Day7 (3h): 手动验证 Planner 生效，并记录 Planner vs 全跑的差异样例。 |
| **第11周** | **结果展示与证据查看（增强）**              | Day1 (3h): 在前端用 `st.dataframe`/`st.table` 展示漏洞明细表格（severity 分类）。 <br/>Day2 (3h): 为每条漏洞增加“展开查看”功能，显示相关代码片段（高亮）与工具证据。 <br/>Day3 (3h): 实现过滤与排序（按 severity、type、文件名）。 <br/>Day4 (3h): 增加“导出报告（JSON/HTML）”按钮并实现导出功能。 <br/>Day5 (3h): 把 Planner 决策日志也展示在前端，便于可解释性演示。 <br/>Day6 (3h): 做一次完整演示并录屏（保存为答辩素材）。 <br/>Day7 (3h): 根据测试用户反馈修正展示细节。 |
| **第12周** | **增强功能与第三方测试**                    | Day1 (3h): 实现“扫描历史”页：查询 DB 并分页显示历史扫描记录。 <br/>Day2 (3h): 邀请 1–2 位同学试用系统，收集错误/可用性反馈（录音/笔记）。 <br/>Day3 (3h): 修复常见问题（非.sol 文件处理、上传失败提示、日志不全）。 <br/>Day4 (3h): 在论文“用户评估”小节记录测试方法与结果。 <br/>Day5 (3h): 准备并运行一轮 20 个合约的批量扫描，收集统计数据（耗时、工具调用次数、检测数）。 <br/>Day6 (3h): 将批量扫描结果用于 baseline/Planner 对比初步分析。 <br/>Day7 (3h): 整理本阶段成果并把前端/后端代码合并到主干。 |

#### **阶段四：收尾答辩 (第13-16周)**

这个阶段的目标是**打磨作品、准备展示**，确保答辩万无一失。Agent 的 LLM 辅助（可选、仅在你有余力）在第13-14周做轻量尝试并严格限制其输出为“建议”而非决策。

| 周数       | 每周核心任务                            | 每日To-do (约3小时)                                          |
| ---------- | --------------------------------------- | ------------------------------------------------------------ |
| **第13周** | **稳定性、容器化与安全审查**            | Day1 (3h): 添加全面错误处理（非.sol、编译错误、工具超时），统一用户提示。 <br/>Day2 (3h): 增加异常监控日志（捕获超时、OOM、工具崩溃），并写日志分析脚本。 <br/>Day3 (3h): 为核心函数写详细 docstring 与内部设计说明。 <br/>Day4 (3h): 打包扫描服务为 Docker 镜像并写 `docker-compose` 运行样例（含资源建议）。 <br/>Day5 (3h): 做容器安全检查（禁网络、只读挂载点、非 root 运行）。 <br/>Day6 (3h): 进行一次恶意输入模拟测试（超大文件、嵌入大量 import）并记录系统反应。 <br/>Day7 (3h): 修复发现的问题并更新部署文档。 |
| **第14周** | **论文写作（实现、实验与 Agent 讨论）** | Day1 (3h): 撰写论文“系统实现”章节（架构图、数据库 schema、关键代码片段）。 <br/>Day2 (3h): 撰写“实验设计”章节（baseline vs Planner 实验方法与指标）。 <br/>Day3 (3h): 撰写“实验结果”初稿（图表：耗时/工具调用/检测率）。 <br/>Day4 (3h): 撰写“Agent 设计与风险”章节（rule-based 描述、LLM 限制、沙箱策略）。 <br/>Day5 (3h): 校对并补充参考文献（SWC、Slither、Mythril、相关事故案例）。 <br/>Day6 (3h): 若有余力，做轻量 LLM 建议器实验（仅输出建议，由 rule 校验）。 <br/>Day7 (3h): 汇总论文草稿并生成初版 PDF。 |
| **第15周** | **准备答辩材料与演示**                  | Day1 (3h): 制作答辩 PPT（背景→设计→实现→实验→Agent→局限与未来工作）。 <br/>Day2 (3h): 准备 2–3 个演示合约（安全/含典型漏洞/复杂合约），并录制演示视频（5–8 分钟）。准备演示合约包括：1 个 Ethernaut 重入关卡、1 个 Ethernaut 溢出关卡、以及 1 个标注为“安全但触发误报/漏报”的合约（用于展示 false positive/false negative 分析） <br/>Day3 (3h): 编写答辩讲稿与 Q&A 清单（预计导师可能问的问题及答案要点）。 <br/>Day4 (3h): 练习 5–10 分钟演示（计时并录音）。 <br/>Day5 (3h): 根据录音调整 PPT 和讲稿。 <br/>Day6 (3h): 准备补充材料（源码链接、运行说明、简易用户手册）。 <br/>Day7 (3h): 最终检查所有提交材料（代码、镜像、论文）。 |
| **第16周** | **模拟答辩与最终检查**                  | Day1 (3h): 进行一次完整模拟答辩（计时、录音），并邀请同学或导师模拟提问。 <br/>Day2 (3h): 回听录音并修改讲稿与 PPT（语速、逻辑、关键图表）。 <br/>Day3 (3h): 最终文档检查：确认 `README`、`requirements.txt`、Docker 镜像说明、论文提交版齐全。 <br/>Day4 (3h): 生成最终提交包（源码压缩、说明文档、演示视频、论文 PDF）。 <br/>Day5 (3h): 做一次线上/线下演示彩排（网络环境、VM 镜像加载测试）。 <br/>Day6 (3h): 心理准备与放松（答辩前一天保持良好状态）。 <br/>Day7 (3h): 提交/交付/答辩日。 |

